"""
Main Window UI Module - Minimal Implementation
This gets your app running with basic UI
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from pathlib import Path
from decimal import Decimal
import json
import logging
from typing import Optional, List, Dict
import threading

from core import ReplayEngine, TradeManager
from models import GameTick
from ui.widgets import ChartWidget, ToastNotification
from bot import BotInterface, BotController, list_strategies

logger = logging.getLogger(__name__)

class MainWindow:
    """
    Main application window with integrated ReplayEngine
    """

    def __init__(self, root: tk.Tk, state, event_bus, config):
        self.root = root
        self.state = state
        self.event_bus = event_bus
        self.config = config

        # Initialize replay engine and trade manager
        self.replay_engine = ReplayEngine(state)
        self.trade_manager = TradeManager(state)

        # Initialize bot
        self.bot_interface = BotInterface(state, self.trade_manager)
        self.bot_controller = BotController(self.bot_interface, "conservative")
        self.bot_enabled = False

        # Set replay callbacks
        self.replay_engine.on_tick_callback = self._on_tick_update
        self.replay_engine.on_game_end_callback = self._on_game_end

        # Initialize toast notifications
        self.toast = None  # Will be initialized after root window is ready

        # Initialize UI
        self._create_ui()
        self._setup_event_handlers()
        self._setup_keyboard_shortcuts()

        logger.info("MainWindow initialized with ReplayEngine")
    
    def _create_ui(self):
        """Create the basic UI structure"""
        # Main container
        self.main_frame = tk.Frame(self.root, bg='#1a1a1a')
        self.main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Title
        title = tk.Label(
            self.main_frame,
            text="Rugs Replay Viewer - Modular Edition",
            font=('Arial', 16, 'bold'),
            bg='#1a1a1a',
            fg='#00ff88'
        )
        title.pack(pady=10)
        
        # Status display
        self.status_frame = tk.Frame(self.main_frame, bg='#2a2a2a')
        self.status_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Current tick info
        self.tick_label = tk.Label(
            self.status_frame,
            text="Tick: 0",
            font=('Arial', 12),
            bg='#2a2a2a',
            fg='white'
        )
        self.tick_label.pack(side=tk.LEFT, padx=10)
        
        # Price display
        self.price_label = tk.Label(
            self.status_frame,
            text="Price: 1.0000x",
            font=('Arial', 12, 'bold'),
            bg='#2a2a2a',
            fg='#00ff88'
        )
        self.price_label.pack(side=tk.LEFT, padx=10)
        
        # Phase display
        self.phase_label = tk.Label(
            self.status_frame,
            text="Phase: UNKNOWN",
            font=('Arial', 12),
            bg='#2a2a2a',
            fg='#ffcc00'
        )
        self.phase_label.pack(side=tk.LEFT, padx=10)
        
        # Balance display
        self.balance_label = tk.Label(
            self.status_frame,
            text=f"Balance: {self.state.get('balance'):.4f} SOL",
            font=('Arial', 12),
            bg='#2a2a2a',
            fg='white'
        )
        self.balance_label.pack(side=tk.RIGHT, padx=10)

        # ========== PRICE CHART ==========
        self.chart_frame = tk.Frame(self.main_frame, bg='#1a1a1a')
        self.chart_frame.pack(fill=tk.X, padx=10, pady=10)  # Changed: fill=tk.X, removed expand

        self.chart = ChartWidget(self.chart_frame, width=760, height=300)
        self.chart.pack()

        # Chart controls
        self.chart_controls_frame = tk.Frame(self.main_frame, bg='#2a2a2a')
        self.chart_controls_frame.pack(fill=tk.X, padx=10, pady=(0, 10))

        # Zoom buttons
        self.zoom_in_btn = tk.Button(
            self.chart_controls_frame,
            text="üîç+ Zoom In",
            command=self.chart.zoom_in,
            bg='#444444',
            fg='white',
            font=('Arial', 9)
        )
        self.zoom_in_btn.pack(side=tk.LEFT, padx=5)

        self.zoom_out_btn = tk.Button(
            self.chart_controls_frame,
            text="üîç- Zoom Out",
            command=self.chart.zoom_out,
            bg='#444444',
            fg='white',
            font=('Arial', 9)
        )
        self.zoom_out_btn.pack(side=tk.LEFT, padx=5)

        self.zoom_reset_btn = tk.Button(
            self.chart_controls_frame,
            text="‚Üª Reset Zoom",
            command=self.chart.reset_zoom,
            bg='#444444',
            fg='white',
            font=('Arial', 9)
        )
        self.zoom_reset_btn.pack(side=tk.LEFT, padx=5)

        # Chart info label
        self.chart_info_label = tk.Label(
            self.chart_controls_frame,
            text="Chart: 0 ticks",
            bg='#2a2a2a',
            fg='#666666',
            font=('Arial', 9)
        )
        self.chart_info_label.pack(side=tk.RIGHT, padx=10)

        # Control buttons
        self.controls_frame = tk.Frame(self.main_frame, bg='#2a2a2a')
        self.controls_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Load button
        self.load_button = tk.Button(
            self.controls_frame,
            text="üìÅ Load Game",
            command=self.load_game,
            bg='#3366ff',
            fg='white',
            font=('Arial', 10, 'bold')
        )
        self.load_button.pack(side=tk.LEFT, padx=5)
        
        # Play/Pause button
        self.play_button = tk.Button(
            self.controls_frame,
            text="‚ñ∂Ô∏è Play",
            command=self.toggle_playback,
            bg='#00ff88',
            fg='black',
            font=('Arial', 10, 'bold'),
            state=tk.DISABLED
        )
        self.play_button.pack(side=tk.LEFT, padx=5)
        
        # Step button
        self.step_button = tk.Button(
            self.controls_frame,
            text="‚è≠Ô∏è Step",
            command=self.step_forward,
            bg='#666666',
            fg='white',
            font=('Arial', 10, 'bold'),
            state=tk.DISABLED
        )
        self.step_button.pack(side=tk.LEFT, padx=5)
        
        # Reset button
        self.reset_button = tk.Button(
            self.controls_frame,
            text="üîÑ Reset",
            command=self.reset_game,
            bg='#ff3366',
            fg='white',
            font=('Arial', 10, 'bold'),
            state=tk.DISABLED
        )
        self.reset_button.pack(side=tk.LEFT, padx=5)
        
        # Trading panel placeholder
        self.trading_frame = tk.LabelFrame(
            self.main_frame,
            text="Trading Controls",
            bg='#2a2a2a',
            fg='white',
            font=('Arial', 10, 'bold')
        )
        self.trading_frame.pack(fill=tk.X, padx=10, pady=5)

        # ========== BET INPUT SECTION ==========
        bet_input_frame = tk.Frame(self.trading_frame, bg='#2a2a2a')
        bet_input_frame.pack(fill=tk.X, padx=10, pady=(10, 5))

        tk.Label(bet_input_frame, text="BET AMOUNT",
                fg='#666666', bg='#2a2a2a',
                font=('Arial', 9)).pack(anchor=tk.W, pady=(0, 5))

        # Entry container with SOL label
        input_container = tk.Frame(bet_input_frame, bg='#1a1a1a', relief=tk.RAISED, bd=1)
        input_container.pack(fill=tk.X)

        self.bet_entry = tk.Entry(input_container,
                                 bg='#1a1a1a', fg='white',
                                 font=('Arial', 14, 'bold'),
                                 bd=0, insertbackground='white',
                                 justify=tk.RIGHT)
        self.bet_entry.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=8)
        self.bet_entry.insert(0, str(self.config.FINANCIAL['default_bet']))

        tk.Label(input_container, text="SOL",
                fg='#666666', bg='#1a1a1a',
                font=('Arial', 12)).pack(side=tk.RIGHT, padx=10)

        # Quick bet buttons row
        quick_bet_frame = tk.Frame(self.trading_frame, bg='#2a2a2a')
        quick_bet_frame.pack(fill=tk.X, padx=10, pady=(0, 10))

        # Clear button (X)
        clear_btn = tk.Button(quick_bet_frame, text="X",
                            bg='#ff3366', fg='#ffffff',
                            font=('Arial', 9, 'bold'), bd=1, relief=tk.RAISED,
                            command=self.clear_bet_amount)
        clear_btn.pack(side=tk.LEFT, padx=2, fill=tk.X, expand=True)

        # Increment buttons
        for amount in [Decimal('0.001'), Decimal('0.005'), Decimal('0.010'), Decimal('0.025')]:
            btn = tk.Button(quick_bet_frame, text=f"+{amount}",
                          bg='#3a3a3a', fg='#00ff88',
                          font=('Arial', 9), bd=1, relief=tk.RAISED,
                          command=lambda a=amount: self.increment_bet_amount(a))
            btn.pack(side=tk.LEFT, padx=2, fill=tk.X, expand=True)

        # Buy button
        self.buy_button = tk.Button(
            self.trading_frame,
            text="üí∞ BUY",
            command=self.execute_buy,
            bg='#00ff88',
            fg='black',
            font=('Arial', 12, 'bold'),
            width=10,
            state=tk.DISABLED
        )
        self.buy_button.pack(side=tk.LEFT, padx=10, pady=10)
        
        # Sell button
        self.sell_button = tk.Button(
            self.trading_frame,
            text="üí∏ SELL",
            command=self.execute_sell,
            bg='#ff3366',
            fg='white',
            font=('Arial', 12, 'bold'),
            width=10,
            state=tk.DISABLED
        )
        self.sell_button.pack(side=tk.LEFT, padx=10, pady=10)
        
        # Sidebet button
        self.sidebet_button = tk.Button(
            self.trading_frame,
            text="üé≤ SIDE BET",
            command=self.execute_sidebet,
            bg='#ffcc00',
            fg='black',
            font=('Arial', 12, 'bold'),
            width=10,
            state=tk.DISABLED
        )
        self.sidebet_button.pack(side=tk.LEFT, padx=10, pady=10)
        
        # Position display
        self.position_label = tk.Label(
            self.trading_frame,
            text="No Position",
            bg='#2a2a2a',
            fg='#666666',
            font=('Arial', 10)
        )
        self.position_label.pack(side=tk.RIGHT, padx=10)

        # ========== BOT CONTROLS ==========
        self.bot_frame = tk.LabelFrame(
            self.main_frame,
            text="Bot Controller",
            bg='#2a2a2a',
            fg='white',
            font=('Arial', 10, 'bold')
        )
        self.bot_frame.pack(fill=tk.X, padx=10, pady=5)

        # Enable/Disable bot button
        self.bot_toggle_button = tk.Button(
            self.bot_frame,
            text="ü§ñ Enable Bot",
            command=self.toggle_bot,
            bg='#666666',
            fg='white',
            font=('Arial', 10, 'bold'),
            width=15,
            state=tk.DISABLED
        )
        self.bot_toggle_button.pack(side=tk.LEFT, padx=10, pady=10)

        # Strategy selector
        strategy_label = tk.Label(
            self.bot_frame,
            text="Strategy:",
            bg='#2a2a2a',
            fg='white',
            font=('Arial', 10)
        )
        strategy_label.pack(side=tk.LEFT, padx=(10, 5))

        self.strategy_var = tk.StringVar(value="conservative")
        self.strategy_dropdown = ttk.Combobox(
            self.bot_frame,
            textvariable=self.strategy_var,
            values=list_strategies(),
            state='readonly',
            width=15
        )
        self.strategy_dropdown.pack(side=tk.LEFT, padx=5)
        self.strategy_dropdown.bind('<<ComboboxSelected>>', self._on_strategy_changed)

        # Bot status label
        self.bot_status_label = tk.Label(
            self.bot_frame,
            text="Bot: Disabled",
            bg='#2a2a2a',
            fg='#666666',
            font=('Arial', 10)
        )
        self.bot_status_label.pack(side=tk.RIGHT, padx=10)

        # Progress bar
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(
            self.main_frame,
            variable=self.progress_var,
            maximum=100
        )
        self.progress_bar.pack(fill=tk.X, padx=10, pady=5)
        
        # Log display
        self.log_frame = tk.LabelFrame(
            self.main_frame,
            text="Event Log",
            bg='#2a2a2a',
            fg='white'
        )
        self.log_frame.pack(fill=tk.X, padx=10, pady=5)  # Changed: fill=tk.X, removed expand

        self.log_text = tk.Text(
            self.log_frame,
            height=8,  # Reduced from 10 to 8
            bg='#0a0a0a',
            fg='#00ff88',
            font=('Courier', 9)
        )
        self.log_text.pack(fill=tk.X, padx=5, pady=5)  # Changed: fill=tk.X, removed expand
        
        # Add scrollbar
        scrollbar = tk.Scrollbar(self.log_text)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.log_text.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=self.log_text.yview)

        # Initialize toast notifications (after root window is ready)
        self.toast = ToastNotification(self.root)

        self.log("UI Initialized - Ready to load game files")
    
    def _setup_event_handlers(self):
        """Setup event bus subscriptions"""
        from services.event_bus import Events
        
        # Subscribe to game events
        self.event_bus.subscribe(Events.GAME_TICK, self._handle_game_tick)
        self.event_bus.subscribe(Events.TRADE_EXECUTED, self._handle_trade_executed)
        self.event_bus.subscribe(Events.TRADE_FAILED, self._handle_trade_failed)
        self.event_bus.subscribe(Events.FILE_LOADED, self._handle_file_loaded)
        
        # Subscribe to state events
        from core.game_state import StateEvents
        self.state.subscribe(StateEvents.BALANCE_CHANGED, self._handle_balance_changed)
        self.state.subscribe(StateEvents.POSITION_OPENED, self._handle_position_opened)
        self.state.subscribe(StateEvents.POSITION_CLOSED, self._handle_position_closed)
    
    def log(self, message: str):
        """Add message to log display"""
        self.log_text.insert(tk.END, f"{message}\n")
        self.log_text.see(tk.END)
    
    def load_game(self):
        """Load a game file"""
        filepath = filedialog.askopenfilename(
            title="Select Game Recording",
            filetypes=[("JSONL files", "*.jsonl"), ("All files", "*.*")]
        )
        
        if filepath:
            try:
                self.load_game_file(Path(filepath))
            except Exception as e:
                messagebox.showerror("Load Error", f"Failed to load game: {e}")
    
    def load_game_file(self, filepath: Path):
        """Load game data from file using ReplayEngine"""
        success = self.replay_engine.load_file(filepath)

        if success:
            info = self.replay_engine.get_info()
            self.log(f"Loaded game with {info['total_ticks']} ticks")

            # Enable controls
            self.play_button.config(state=tk.NORMAL)
            self.step_button.config(state=tk.NORMAL)
            self.reset_button.config(state=tk.NORMAL)
            self.bot_toggle_button.config(state=tk.NORMAL)
        else:
            self.log("Failed to load game file")
            messagebox.showerror("Load Error", "Failed to load game file")
    
# display_tick() removed - now handled by ReplayEngine callbacks
    
    def toggle_playback(self):
        """Toggle play/pause using ReplayEngine"""
        if self.replay_engine.is_playing:
            self.replay_engine.pause()
            self.play_button.config(text="‚ñ∂Ô∏è Play")
        else:
            self.replay_engine.play()
            self.play_button.config(text="‚è∏Ô∏è Pause")
    
    def step_forward(self):
        """Step forward one tick using ReplayEngine"""
        if not self.replay_engine.step_forward():
            self.log("Reached end of game")
            self.play_button.config(text="‚ñ∂Ô∏è Play")
    
    def reset_game(self):
        """Reset to beginning using ReplayEngine"""
        self.replay_engine.reset()
        self.chart.clear_history()
        self.play_button.config(text="‚ñ∂Ô∏è Play")
        self.log("Game reset")
    
    def execute_buy(self):
        """Execute buy action using TradeManager"""
        amount = self.get_bet_amount()
        if amount is None:
            return  # Validation failed (toast already shown)

        result = self.trade_manager.execute_buy(amount)

        if result['success']:
            self.log(f"BUY executed at {result['price']:.4f}x")
            self.toast.show(f"Bought {amount} SOL at {result['price']:.4f}x", "success")
        else:
            self.log(f"BUY failed: {result['reason']}")
            self.toast.show(f"Buy failed: {result['reason']}", "error")
    
    def execute_sell(self):
        """Execute sell action using TradeManager"""
        result = self.trade_manager.execute_sell()

        if result['success']:
            pnl = result.get('pnl_sol', 0)
            pnl_pct = result.get('pnl_percent', 0)
            msg_type = "success" if pnl >= 0 else "error"
            self.log(f"SELL executed - P&L: {pnl:+.4f} SOL")
            self.toast.show(f"Sold! P&L: {pnl:+.4f} SOL ({pnl_pct:+.1f}%)", msg_type)
        else:
            self.log(f"SELL failed: {result['reason']}")
            self.toast.show(f"Sell failed: {result['reason']}", "error")
    
    def execute_sidebet(self):
        """Execute sidebet using TradeManager"""
        amount = self.get_bet_amount()
        if amount is None:
            return  # Validation failed (toast already shown)

        result = self.trade_manager.execute_sidebet(amount)

        if result['success']:
            potential_win = result.get('potential_win', 0)
            self.log(f"SIDEBET placed ({amount} SOL)")
            self.toast.show(f"Side bet placed! {amount} SOL (potential: {potential_win:.4f} SOL)", "warning")
        else:
            self.log(f"SIDEBET failed: {result['reason']}")
            self.toast.show(f"Side bet failed: {result['reason']}", "error")

    # ========================================================================
    # BOT CONTROLS
    # ========================================================================

    def toggle_bot(self):
        """Toggle bot enable/disable"""
        self.bot_enabled = not self.bot_enabled

        if self.bot_enabled:
            self.bot_toggle_button.config(
                text="ü§ñ Disable Bot",
                bg='#ff3366'
            )
            self.bot_status_label.config(
                text=f"Bot: ACTIVE ({self.strategy_var.get()})",
                fg='#00ff88'
            )
            # Disable manual trading when bot is active
            self.buy_button.config(state=tk.DISABLED)
            self.sell_button.config(state=tk.DISABLED)
            self.sidebet_button.config(state=tk.DISABLED)
            self.log(f"ü§ñ Bot enabled with {self.strategy_var.get()} strategy")
        else:
            self.bot_toggle_button.config(
                text="ü§ñ Enable Bot",
                bg='#666666'
            )
            self.bot_status_label.config(
                text="Bot: Disabled",
                fg='#666666'
            )
            self.log("ü§ñ Bot disabled")

    def _on_strategy_changed(self, event):
        """Handle strategy selection change"""
        from bot import get_strategy

        strategy_name = self.strategy_var.get()
        try:
            # Update bot controller with new strategy
            strategy = get_strategy(strategy_name)
            self.bot_controller.strategy = strategy
            self.log(f"Strategy changed to: {strategy_name}")

            # Update status if bot is active
            if self.bot_enabled:
                self.bot_status_label.config(
                    text=f"Bot: ACTIVE ({strategy_name})"
                )
        except Exception as e:
            self.log(f"Failed to change strategy: {e}")

    # ========================================================================
    # REPLAY ENGINE CALLBACKS
    # ========================================================================

    def _on_tick_update(self, tick: GameTick, index: int, total: int):
        """Callback for ReplayEngine tick updates"""
        # Update UI labels
        self.tick_label.config(text=f"Tick: {tick.tick}")
        self.price_label.config(text=f"Price: {tick.price:.4f}x")
        self.phase_label.config(text=f"Phase: {tick.phase}")

        # Update progress bar
        progress = (index / total) * 100 if total > 0 else 0
        self.progress_var.set(progress)

        # Update chart
        self.chart.add_tick(tick.tick, tick.price)

        # Update chart info
        chart_info = self.chart.get_info()
        self.chart_info_label.config(
            text=f"Chart: {chart_info['tick_count']} ticks | "
                 f"Range: {chart_info['min_price']:.2f}x - {chart_info['max_price']:.2f}x"
        )

        # ========== BOT EXECUTION ==========
        if self.bot_enabled:
            try:
                result = self.bot_controller.execute_step()

                # Update bot status with action taken
                action = result.get('action', 'WAIT')
                reasoning = result.get('reasoning', '')
                success = result.get('success', False)

                if action != 'WAIT':
                    status_text = f"Bot: {action}"
                    if reasoning:
                        status_text += f" ({reasoning[:30]}...)" if len(reasoning) > 30 else f" ({reasoning})"

                    self.bot_status_label.config(
                        text=status_text,
                        fg='#00ff88' if success else '#ff3366'
                    )

                    # Log bot action
                    if success:
                        self.log(f"ü§ñ Bot: {action} - {reasoning}")
                    else:
                        self.log(f"ü§ñ Bot: {action} FAILED - {result.get('reason', 'Unknown')}")

            except Exception as e:
                self.log(f"ü§ñ Bot error: {e}")
                self.bot_enabled = False
                self.bot_toggle_button.config(
                    text="ü§ñ Enable Bot",
                    bg='#666666'
                )
                self.bot_status_label.config(
                    text="Bot: Error",
                    fg='#ff3366'
                )

        # Update button states based on phase (only when bot disabled)
        if not self.bot_enabled:
            if tick.is_tradeable():
                self.buy_button.config(state=tk.NORMAL)
                if not self.state.get('sidebet'):
                    self.sidebet_button.config(state=tk.NORMAL)
            else:
                self.buy_button.config(state=tk.DISABLED)
                self.sidebet_button.config(state=tk.DISABLED)

            # Check position status
            position = self.state.get('position')
            if position and position.get('status') == 'active':
                self.sell_button.config(state=tk.NORMAL)
                pnl_pct = ((tick.price / position['entry_price']) - 1) * 100
                self.position_label.config(
                    text=f"Position: {pnl_pct:+.1f}%",
                    fg='#00ff88' if pnl_pct > 0 else '#ff3366'
                )
            else:
                self.sell_button.config(state=tk.DISABLED)
                self.position_label.config(text="No Position", fg='#666666')
        else:
            # Keep position display updated even when bot is active
            position = self.state.get('position')
            if position and position.get('status') == 'active':
                pnl_pct = ((tick.price / position['entry_price']) - 1) * 100
                self.position_label.config(
                    text=f"Position: {pnl_pct:+.1f}%",
                    fg='#00ff88' if pnl_pct > 0 else '#ff3366'
                )
            else:
                self.position_label.config(text="No Position", fg='#666666')

    def _on_game_end(self, metrics: dict):
        """Callback for game end"""
        self.log(f"Game ended. Final balance: {metrics.get('current_balance', 0):.4f} SOL")
        self.play_button.config(text="‚ñ∂Ô∏è Play")

    # ========================================================================
    # EVENT HANDLERS
    # ========================================================================

    def _handle_game_tick(self, event):
        """Handle game tick event"""
        # Now handled by ReplayEngine callbacks
        pass
    
    def _handle_trade_executed(self, event):
        """Handle successful trade"""
        self.log(f"Trade executed: {event.get('data')}")
    
    def _handle_trade_failed(self, event):
        """Handle failed trade"""
        self.log(f"Trade failed: {event.get('data')}")
    
    def _handle_file_loaded(self, event):
        """Handle file loaded event"""
        files = event.get('data', {}).get('files', [])
        if files:
            self.log(f"Found {len(files)} game files")
            # Auto-load first file
            self.load_game_file(files[0])
    
    def _handle_balance_changed(self, data):
        """Handle balance change"""
        new_balance = data.get('new', self.state.get('balance'))
        self.balance_label.config(text=f"Balance: {new_balance:.4f} SOL")
    
    def _handle_position_opened(self, data):
        """Handle position opened"""
        self.log(f"Position opened at {data.get('entry_price', 0):.4f}")
    
    def _handle_position_closed(self, data):
        """Handle position closed"""
        pnl = data.get('pnl_sol', 0)
        self.log(f"Position closed - P&L: {pnl:+.4f} SOL")

    # ========================================================================
    # BET AMOUNT METHODS
    # ========================================================================

    def set_bet_amount(self, amount: Decimal):
        """Set bet amount from quick buttons or manual input"""
        self.bet_entry.delete(0, tk.END)
        self.bet_entry.insert(0, str(amount))
        logger.debug(f"Bet amount set to {amount}")

    def increment_bet_amount(self, amount: Decimal):
        """Increment bet amount by specified amount"""
        try:
            current_amount = Decimal(self.bet_entry.get())
        except Exception:
            current_amount = Decimal('0')

        new_amount = current_amount + amount
        self.bet_entry.delete(0, tk.END)
        self.bet_entry.insert(0, str(new_amount))
        logger.debug(f"Bet amount incremented by {amount} to {new_amount}")

    def clear_bet_amount(self):
        """Clear bet amount to zero"""
        self.bet_entry.delete(0, tk.END)
        self.bet_entry.insert(0, "0")
        logger.debug("Bet amount cleared to 0")

    def get_bet_amount(self) -> Optional[Decimal]:
        """
        Get and validate bet amount from entry

        Returns:
            Decimal amount if valid, None otherwise
        """
        try:
            bet_amount = Decimal(self.bet_entry.get())

            min_bet = self.config.FINANCIAL['min_bet']
            max_bet = self.config.FINANCIAL['max_bet']

            if bet_amount < min_bet:
                self.toast.show(f"Bet must be at least {min_bet} SOL", "error")
                return None

            if bet_amount > max_bet:
                self.toast.show(f"Bet cannot exceed {max_bet} SOL", "error")
                return None

            balance = self.state.get('balance')
            if bet_amount > balance:
                self.toast.show(f"Insufficient balance! Have {balance:.4f} SOL", "error")
                return None

            return bet_amount

        except Exception as e:
            self.toast.show("Invalid bet amount", "error")
            logger.error(f"Invalid bet amount: {e}")
            return None

    # ========================================================================
    # KEYBOARD SHORTCUTS
    # ========================================================================

    def _setup_keyboard_shortcuts(self):
        """Setup keyboard shortcuts for common actions"""
        self.root.bind('<space>', lambda e: self.toggle_playback())
        self.root.bind('b', lambda e: self.execute_buy() if self.buy_button['state'] != tk.DISABLED else None)
        self.root.bind('B', lambda e: self.execute_buy() if self.buy_button['state'] != tk.DISABLED else None)
        self.root.bind('s', lambda e: self.execute_sell() if self.sell_button['state'] != tk.DISABLED else None)
        self.root.bind('S', lambda e: self.execute_sell() if self.sell_button['state'] != tk.DISABLED else None)
        self.root.bind('d', lambda e: self.execute_sidebet() if self.sidebet_button['state'] != tk.DISABLED else None)
        self.root.bind('D', lambda e: self.execute_sidebet() if self.sidebet_button['state'] != tk.DISABLED else None)
        self.root.bind('r', lambda e: self.reset_game())
        self.root.bind('R', lambda e: self.reset_game())
        self.root.bind('<Left>', lambda e: self.step_backward())
        self.root.bind('<Right>', lambda e: self.step_forward())
        self.root.bind('<h>', lambda e: self.show_help())
        self.root.bind('<H>', lambda e: self.show_help())

        logger.info("Keyboard shortcuts configured")

    def step_backward(self):
        """Step backward one tick"""
        if self.replay_engine.step_backward():
            self.log("Stepped backward")

    def show_help(self):
        """Show help dialog with keyboard shortcuts"""
        help_text = """
KEYBOARD SHORTCUTS:

Trading:
  B - Buy (open position)
  S - Sell (close position)
  D - Place side bet

Playback:
  Space - Play/Pause
  R - Reset game
  ‚Üê - Step backward
  ‚Üí - Step forward

Other:
  H - Show this help

GAME RULES:
‚Ä¢ Side bets win if rug occurs within 40 ticks
‚Ä¢ Side bet pays 5x your wager
‚Ä¢ After side bet resolves, 5 tick cooldown before next bet
‚Ä¢ All positions are lost when rug occurs
"""
        messagebox.showinfo("Help - Keyboard Shortcuts", help_text)
